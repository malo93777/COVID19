# -*- coding: utf-8 -*-
"""covid19.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PTe6S3NYQhn02OI0yx21I44vabmgZnlR
"""

import os
import numpy as np
import pandas as pd
import cv2
import matplotlib.pyplot as plt
import seaborn as sn
from random import shuffle
from shutil import copyfile
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from math import sqrt

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten, Dropout
from tensorflow.keras.layers import Conv2D, MaxPooling2D

"""COSTANTI"""

IMG_SIZE = (500, 500)
BATCH_SIZE = 16

"""DATASET"""

if(not os.path.isdir("dataset")):
  os.mkdir("dataset/")
  os.mkdir("dataset/covid")
  os.mkdir("dataset/normal")

"""RADIOGRAFIE PAZIENTI COVID-19"""

!git clone https://github.com/ieee8023/covid-chestxray-dataset.git

df = pd.read_csv("/content/covid-chestxray-dataset/metadata.csv")
df.head()

"""Creo filtro per selezionare solo le righe con 'view' = PA, poichè i casi sani hanno solo PA (lastra posteranteriore del torace), e con diagnosi 'finding' = COVID-19"""

df = df[(df['finding']=='COVID-19') & (df['view']=='PA')]
df.head()

imgs_covid = list(df["filename"])
imgs_covid[:10]

imgs_covid_count = len(imgs_covid)
imgs_covid_count

def copy_samples(imgs_list, imgs_path, cls):
  for img in imgs_list:
    copyfile(imgs_path+img, 'dataset/'+ cls + '/' + img)

copy_samples(imgs_covid[:145], 'covid-chestxray-dataset/images/', 'covid')

"""RADIOGRAFIE PAZIENTI SANI"""

imgs_normal = os.listdir('/content/drive/My Drive/chest_xray/train/NORMAL')
imgs_normal[:10]
shuffle(imgs_normal)
imgs_normal = imgs_normal[:145]
len(imgs_normal)
copy_samples(imgs_normal, '/content/drive/My Drive/chest_xray/train/NORMAL/', 'normal')

"""**PREPROCESSING DELLE IMMAGINI**"""

X = []
y = []

encoding = [('normal', 0), ('covid', 1)]

for folder, label in encoding:
  current_folder = 'dataset/'+folder+'/'
  for img_name in os.listdir(current_folder):
    img = cv2.imread(current_folder + img_name, cv2.IMREAD_GRAYSCALE)
    img = cv2.equalizeHist(img)
    img = cv2.resize(img, IMG_SIZE)/255.

    X.append(img)
    y.append(label)

X = np.array(X)
y = np.array(y)

X.shape

def show_sample(X):

  fig = plt.figure()

  for i in range(X.shape[0]):
    plot = fig.add_subplot(1, X.shape[0], i+1)
    plt.imshow(X[i])
    plt.axis('off')

show_sample(X[:5])

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, stratify=y)

X_train.shape

X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], X_train.shape[2], 1)
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], X_test.shape[2], 1)

"""**DATA AUGMENTATION**
 
 Genero nuove immagini prima ruotando di 15° quelle originali poi aumentandone la luminosità.
"""

datagen = ImageDataGenerator(
    rotation_range = 15,
    brightness_range = [0.2, 1.0]
)

train_generator = datagen.flow(
    X_train,
    y_train,
    batch_size = BATCH_SIZE
)

"""**ADDESTRAMENTO RETE NEURALE CONVOLUZIONALE**

1.   Primo strato convoluzionale con input(DIMENSIONE IMMAGINE E NUMERO CANALI)

1.   Secondo strato convoluzionale

1.   Terzo strato di Flattening per spacchettare gli array in un unico vettore
2.   Quarto strato denso con 64 neuroni

5.   Quinto strato binario con sigmoidale
"""

model = Sequential()
model.add(Conv2D(filters=32, kernel_size=3, activation='relu', input_shape=(IMG_SIZE[0], IMG_SIZE[1], 1)))
model.add(MaxPooling2D(pool_size=2)) 
model.add(Dropout(0.6))
model.add(Conv2D(filters=32, kernel_size=3, activation='relu'))
model.add(MaxPooling2D(pool_size=2)) 
model.add(Dropout(0.6))
model.add(Flatten())
model.add(Dense(64, activation='relu'))
model.add(Dropout(0.6))
model.add(Dense(1, activation='sigmoid'))

model.summary()

model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
model.fit(train_generator, epochs=100, steps_per_epoch=X_train.shape[0]//BATCH_SIZE)

metrics_train = model.evaluate(X_train, y_train)
metrics_test = model.evaluate(X_test, y_test)

print('Train accuracy = %.4f - Train loss = %.4f' % (metrics_train[1],metrics_train[0]))
print('Test accuracy = %.4f - Test loss = %.4f' % (metrics_test[1],metrics_test[0]))

"""MATRICE DI CONFUSIONE"""

y_pred = model.predict_classes(X_test)

cm = confusion_matrix(y_test, y_pred)

df_cm = pd.DataFrame(cm, index=['Predicted Covid', 'Predicted Normal'], columns = ['Covid', 'Normal'])
sn.heatmap(df_cm, annot=True)

"""COVID O POLMONITE?

creo un dataset di polmoniti NON covid da passare al modello per capire se riesce a distinguere una polmonite 'normale' da una causata da coronavirus.
"""

os.mkdir('dataset/pneumonia')

imgs_pneumonia = os.listdir('/content/drive/My Drive/chest_xray/train/PNEUMONIA/')
shuffle(imgs_pneumonia)
imgs_pneumonia = imgs_pneumonia[:imgs_covid_count]

copy_samples(imgs_pneumonia, '/content/drive/My Drive/chest_xray/train/PNEUMONIA/', 'pneumonia')

X_pneumonia = []

for img_name in os.listdir('dataset/pneumonia'):

  img = cv2.imread('dataset/pneumonia/' + img_name, cv2.IMREAD_GRAYSCALE)
  img = cv2.equalizeHist(img)
  img = cv2.resize(img,IMG_SIZE)/255
  X_pneumonia.append(img)
  
X_pneumonia = np.array(X_pneumonia)
show_sample(X_pneumonia[:5])

X_pneumonia.shape

X_pneumonia = X_pneumonia.reshape(X_pneumonia.shape[0], X_pneumonia.shape[1],  X_pneumonia.shape[2], 1)

X_pneumonia.shape

y_pred = model.predict_classes(X_pneumonia)

"""POLMONITI NORMALI CLASSIFICATE COME COVID:"""

misclassified_count = y_pred[y_pred==1].shape[0]
misclassified_count

"""POLMONITI DA CORONAVIRUS CLASSIFICATE COME COVID"""

pneumonia_samples_count = X_pneumonia.shape[0]
pneumonia_samples_count

missclassified_percentage = round(misclassified_count*100/pneumonia_samples_count, 2)
print("Pazienti con polmonite classificati come affetti da COVID-19 = %d/%d (%.2f%%)" % (misclassified_count, pneumonia_samples_count, missclassified_percentage))

"""**TEST DELLA RETE NEURALE (ipotizzando di avere nuove lastre)**"""

labels = ['normal', 'covid']
colors = ['green', 'red']

pred = model.predict_classes(X_test)

fig = plt.figure(figsize=(14, 16))
fig.subplots_adjust(wspace=0, hspace=0)

n_cols = int(sqrt(X_test.shape[0]))
n_rows = X_test.shape[0]//n_cols+1

for i in range(X_test.shape[0]):
  plot = fig.add_subplot(n_rows, n_cols, i+1)
  plt.imshow(X_test[i].reshape(200, 200), cmap = 'gray')
  class_index = pred[i][0]

  plt.text(5, 25, labels[class_index], fontsize=14, color=colors[class_index], fontdict= {'weight':'bold'})
  plt.axis('off')